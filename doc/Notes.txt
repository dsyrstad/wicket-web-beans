v2.0
----
- PropertyProxyModels can be a listener and mark itself as dirty. Then any higher
level component can traverse the component model see if any model is dirty.
However, this doesn't help having properties that are values to component
properties. The component would need to register itself as a listener.
 - PPModel registers itself as a listener. The creator of the PPM will determine if
 it is being attached to a component. If it is, the component is attached to model.
 when a change occurs, the component is added to the AjaxTarget (found via RequestCycle).
 - Components/Beans that are set from a property: PropertyProxyModel/PropertyProxy
 could take a property name to set (another PropertyProxy?), like bean factory is doing. Then the PPModel
 would just hang around as a listener and propagator of the change.
 - The Component binding to PPModel (and bean PCListener) should be weak so they can be collected.

- Problem: A multi-component property spec may have intermediate property changes (including
  collection changes) that would change which bean is being listened to.
  - Possible solution: create a session/thread local-based PropertyChangeDispatcher
    that will catch all bean changes. This would match against PropertyBinders that
    eventually point to the changed object property. This way we don't need to register
    listeners on each bean. 
    - Matching could be time consuming but binders should go away when components do.
    - See notebook SwiXML which is doing something similar with OGNL. Nice diagram
      of mapping of components to beans.
    - Check bean binding JSR

- OGNL (defunct?) and BeanUtils are other possible property mappers. 
 
- Special "control" params like colspan that are not properties of the bean
  should be indicated with _ - just by convention.
- System config that is loaded first with BeanFactory - common defs
- Elements are explicitly called out - no auto-derivation of elements from bean. However, can auto-derive label.
- If we want pre-built components, then where do actions reside? ThreadLocal context that has component, AjaxRequestTarget, bean. 
  Then we can call on any bean. Action method can return a List of ValidationMessages or IValidationError / ValidationError.
  What about info/warn messages? 
- ValidationMessage can have property name/expression - then message will be associated with that property.
- Support attachment of IValidator to fields. Support construction in here.
- Components are really beans .... So we could construct an IValidator above. Then it's starting to look a little spring-like.
- PropertyResolver plugin. Default will be JXPath.

- Only generic parameter is "class" or "component". 
- No automatic nesting of bean forms....
- How do dynamic values trigger? Do we evaluate each time? 
- How is config found? Can be optionally explicit (InputStream/Reader or URL). 
- parameters are properties on beans?

- Use new Wicket-stuff data grid (http://wicketstuff.org/grid-examples/data-grid/simple.2)
- TinyMCE support at wicket-stuff: wicket-contrib-tinymce
- Wicket ExtJS support (beginnings) at http://www.wickettools.org

- Component Composition

- ComponentRegistry can register one of these pre-configured components.
- How does initial matching of component name work? Passed to BeanConfig as option, otherwise based on the 
bean class? Since implicit nesting of beans is no longer supported, it could just be called out in the constructor or
default to the "ROOT" component. 

- Distinguish parameter values as literals ("xyz", 5, 5.5) or symbols (prop/path/expr). Symbols are those that are
  not literals. 

- Automagic property change support via Ener-J derived agent. (Later) 


Component0 {
	class: TabbedLayout; # or component: for a pre-defined component - inherits those parameters and extends them.
	components: Component1 { label: "First Tab" }, Component4 { label: "Second Tab", displayed: someBooleanProp };
----> Shouldn't you be able to have a combination of properties and components? Properties could be literal strings
and components values
}

Component1 {
	class: BeanForm;
	layout: BeanGridPanel;
	elements: 
		"prop1/prop2" { params }, 
		"prop3/collection" { component: Component2, override-props-for-component: x },
		"prop3/collection" { class: ComponentClass, properties... },
		prop5 { label : ${prop6/prop7} };  # Dynamic values    
}

Component2 { # Table
	class: BeanTable;
	rowComponent: Component3;
	- or -
	rowElements: "prop3", "prop4";
}

Component3 { # Row
	class: BeanTableRow;
	elements: "prop3", "prop4";
}

Component4 {
	class: BeanForm;
	elements: 
		"prop1/prop2" { params }; 
}


----------------------------------
Database-driven Forms
----------------------------------
By using a different PropertyResolver, we could support CRUD via config files and a standard app.

Form { class: ...;
	jdbcInfo: jdbcInfoBean;
	components: table1.column1, table2.column2, ...;
}

jdbcInfoBean {
	class: JdbcInfoBean;
	jdbcDriver: ....;
	jdbcUrl: ...;
	jdbcUserName: ...;
	jdbcPassword: ....;
}

PropertyResolver would track which columns and tables are updated.
