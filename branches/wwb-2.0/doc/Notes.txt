v2.0
----
 
- System config that is loaded first with BeanFactory - common defs
- If we want pre-built components, then where do actions reside? ThreadLocal context that has component, AjaxRequestTarget, bean. 
  Then we can call on any bean. Action method can return a List of ValidationMessages or IValidationError / ValidationError.
  What about info/warn messages? 
- ValidationMessage can have property name/expression - then message will be associated with that property.
- Support attachment of IValidator to fields. Support construction in here.

- How do dynamic values trigger? Do we evaluate each time? 
- How is config found? Can be optionally explicit (InputStream/Reader or URL). 
- parameters are properties on beans?

- Use new Wicket-stuff data grid (http://wicketstuff.org/grid-examples/data-grid/simple.2)
- TinyMCE support at wicket-stuff: wicket-contrib-tinymce
- Wicket ExtJS support (beginnings) at http://www.wickettools.org

- ComponentRegistry can register one of these pre-configured components.

- Automagic property change support via Ener-J derived agent. (Later) 


Component0 {
	class: TabbedLayout; # or component: for a pre-defined component - inherits those parameters and extends them.
	components: Component1 { label: "First Tab" }, Component4 { label: "Second Tab", displayed: someBooleanProp };
----> Shouldn't you be able to have a combination of properties and components? Properties could be literal strings
and components values
}

Component1 {
	class: BeanForm;
	layout: BeanGridPanel;
	elements: 
		"prop1/prop2" { params }, 
		"prop3/collection" { component: Component2, override-props-for-component: x },
		"prop3/collection" { class: ComponentClass, properties... },
		prop5 { label : ${prop6/prop7} };  # Dynamic values    
}

Component2 { # Table
	class: BeanTable;
	rowComponent: Component3;
	- or -
	rowElements: "prop3", "prop4";
}

Component3 { # Row
	class: BeanTableRow;
	elements: "prop3", "prop4";
}

Component4 {
	class: BeanForm;
	elements: 
		"prop1/prop2" { params }; 
}


----------------------------------
Database-driven Forms
----------------------------------
By using a different PropertyResolver, we could support CRUD via config files and a standard app.

Form { class: ...;
	jdbcInfo: jdbcInfoBean;
	components: table1.column1, table2.column2, ...;
}

jdbcInfoBean {
	class: JdbcInfoBean;
	jdbcDriver: ....;
	jdbcUrl: ...;
	jdbcUserName: ...;
	jdbcPassword: ....;
}

PropertyResolver would track which columns and tables are updated.
